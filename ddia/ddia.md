

# 第一部分 数据系统的基石

## 第一章  可靠性、可拓展性、可维护性

现今很多应用程序都是数据密集型（data-intensive）的，而非计算密集型（compute-intensive）的。因此CPU很少成为这类应用的瓶颈，更大的问题通常来自数据量、数据复杂性、以及数据的变更速度。

数据密集型应用通常由标准组件构建而成，标准组件提供了很多通用的功能；例如，许多应用程序都需要：

数据库（database）

存储数据，以便自己或其他应用程序之后能再次找到

缓存（cache）

记住开销昂贵操作的结果，加快读取速度

搜索索引（search indexes）

允许用户按关键字搜索数据，或以各种方式对数据进行过滤

流处理（stream processing）

向其他进程发送消息，进行异步处理

批处理（batch processing）

定期处理累积的大批量数据

如果这些功能听上去平淡无奇，那是因为这些数据系统（data system）是非常成功的抽象

### 可靠性

可以把可靠性粗略理解为“即使出现问题，也能继续正确工作”。

造成错误的原因叫做故障（fault），能预料并应对故障的系统特性可称为容错（fault-tolerant）或韧性（resilient）。
在这类容错系统中，通过故意触发来提高故障率是有意义的

#### 硬件故障

#### 软件错误

#### 认为错误

一项关于大型互联网服务的研究发现，运维配置错误是导致服务中断的首要原因，而硬件故障（服务器或网络）仅导致了10-25％的服务中断【13】。

以最小化犯错机会的方式设计系统。例如，精心设计的抽象、API和管理后台使做对事情更容易，搞砸事情更困难。但如果接口限制太多，人们就会忽略它们的好处而想办法绕开。很难正确把握这种微妙的平衡。
将人们最容易犯错的地方与可能导致失效的地方解耦（decouple）。特别是提供一个功能齐全的非生产环境沙箱（sandbox），使人们可以在不影响真实用户的情况下，使用真实数据安全地探索和实验。
在各个层次进行彻底的测试【3】，从单元测试、全系统集成测试到手动测试。自动化测试易于理解，已经被广泛使用，特别适合用来覆盖正常情况中少见的边缘场景（corner case）。
允许从人为错误中简单快速地恢复，以最大限度地减少失效情况带来的影响。 例如，快速回滚配置变更，分批发布新代码（以便任何意外错误只影响一小部分用户），并提供数据重算工具（以备旧的计算出错）。
配置详细和明确的监控，比如性能指标和错误率。 在其他工程学科中这指的是遥测（telemetry）。 （一旦火箭离开了地面，遥测技术对于跟踪发生的事情和理解失败是至关重要的。）监控可以向我们发出预警信号，并允许我们检查是否有任何地方违反了假设和约束。当出现问题时，指标数据对于问题诊断是非常宝贵的。
良好的管理实践与充分的培训——一个复杂而重要的方面，但超出了本书的范围。

### 可拓展性

服务降级（degradation）的一个常见原因是负载增加
 可扩展性（Scalability）是用来描述系统应对负载增长能力的术语。但是请注意，这不是贴在系统上的一维标签：说“X可扩展”或“Y不可扩展”是没有任何意义的。相反，讨论可扩展性意味着考虑诸如“如果系统以特定方式增长，有什么选项可以应对增长？”和“如何增加计算资源来处理额外的负载？”等问题。

#### 描述负载

先要能简要描述系统的当前负载。负载可以用一些称为负载参数（load parameters）的数字来描述。参数的最佳选择取决于系统架构，它可能是每秒向Web服务器发出的请求、数据库中的读写比率、聊天室中同时活跃的用户数量、缓存命中率或其他东西。

#### 描述性能

一旦系统的负载被描述好，就可以研究当负载增加会发生什么。我们可以从两种角度来看：

增加负载参数并保持系统资源（CPU、内存、网络带宽等）不变时，系统性能将受到什么影响？
增加负载参数并希望保持性能不变时，需要增加多少系统资源？


如果想知道典型场景下用户需要等待多长时间，那么中位数是一个好的度量标准
应时间的高百分位点（也称为尾部延迟（tail latencies））非常重要，因为它们直接影响用户的服务体验。例如亚马逊在描述内部服务的响应时间要求时以99.9百分位点为准，即使它只影响一千个请求中的一个。这是因为请求响应最慢的客户往往也是数据最多的客户

#### 应对负载的方法

跨多台机器部署无状态服务（stateless services）非常简单，但将带状态的数据系统从单节点变为分布式配置则可能引入许多额外复杂度。出于这个原因，常识告诉我们应该将数据库放在单个节点上（纵向扩展），直到扩展成本或可用性需求迫使其改为分布式。

### 可维护性

# 第二部分 分布式网络

## 第七章 事务

### acid

#### 原子性

#### constituency
是应用程序的属性，保证系统遵循一个原则。比如记账系统，出入是可以对的上的。

####  隔离性
没有原子性，错误处理会复杂的多。没有隔离性，并发会出现问题。

#### 单对象的需求

#### 多对象的需求

#### 读在写后

使用行锁隔离事务与读操作，对系统性能影响很大。只有IBM db 和SQL server 使用。大部分数据库使用另一种，记住事务提交前的旧值，如果事务发生时有读，则读旧值。
