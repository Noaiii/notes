一致性和共識

# 一致性保证

# 线性一致性

提供一种新鲜保证，保证

## 什么使得系统线性一致？

## 线性一致和可序列化

## 依赖线性一致性

### 锁定和领导选举

## 约束和唯一性保证

## 跨信道的时序依赖

# 实现线性一致系统

1. 单主复制（可能线性一致）

因为延时，不能保证副本立即知道主库被写入。

2. 共识算法（线性一致）

3. 多主复制（非线性一致）

由于数据中心之间的网络延迟、网络断开等情况，无法保证一个主库被写时，使另一个主库立即知道。

4. 无主复制（也许不是线性一致）
一个写请求发给多个主库，由于延迟，多个主库被写入的时间差造成了线性不一致。




## 线性一致和法定人数



## 线性一致性的代价


## CAP定理

## 线性一致性和网络延迟

# 顺序保证

## 顺序与因果

## 因果顺序不是全序的

### 线性一致性

### 因果性

## 线性一致性强于因果一致性

### 捕获因果关系

# 序列号顺序

## 非因果序列号生成器

## 兰伯特时间戳

## 光有时间戳排序还不够

# 全序广播

全序广播需要满足两个安全属性：
可靠交付（reliable delivery）
​ 没有消息丢失：如果消息被传递到一个节点，它将被传递到所有节点。
全序交付（totally ordered delivery）*
​ 消息以相同的顺序传递给每个节点。

## 使用全序广播

如果每个消息都代表一次数据库的写入，且每个副本都按相同的顺序处理相同的写入，那么副本间将相互保持一致（除了临时的复制延迟）。这个原理被称为状态机复制（state machine replication）

## 使用全序广播实现线性一致性的存储



## 使用线性一致性的存储实现全序广播

# 分布式事务与共识

非正式地讲，目标只是让几个节点达成一致（get serveral nodes to agree on something）。

节点能达成一致，在很多场景下都非常重要，例如：
1. 领导选举
2. 原子提交：原子事务只有在所有参与者投票提交的情况下才能提交，如果有任何参与者需要中止，则必须中止。 共识则允许就任意一个被参与者提出的候选值达成一致。

> 共识的不可能性

你可能已经听说过作者Fischer，Lynch和Paterson之后的FLP结果【68】，它证明，如果存在节点可能崩溃的风险，则不存在总是能够达成共识的算法。答案是FLP结果在异步系统模型中得到了证明，它假定确定性算法不能使用任何时钟或超时。

## 原子提交与二阶段提交（2PC）

### 从单节点到分布式原子提交

### 两阶段提交

1. 应用向协调者请求一个id；
2. 应用在每个单节点启动事务，并捎带这个id；如果出现问题，则协调者或参与者都可以中止；
3. 应用准备提交时，协调者向每个参与者发送一个准备请求，并打上全局事务ID。如果任意一个请求失败或超时
    ，则协调者向所有参与者发送针对该事务id的中止请求
4. 参与者收到准备请求时，需要确保在任意情况下都的确可以提交事务。这包括将所有事务数据写入磁盘（出现故障，电源故障，或硬盘空间不足都不能是稍后拒绝提交的理由）以及检查是否存在任何冲突或违反约束。通过向协调者回答“是”，节点承诺，只要请求，这个事务一定可以不出差错地提交。换句话说，参与者放弃了中止事务的权利，但没有实际提交。
5. 当协调者收到所有准备请求的答复时，会就提交或中止事务作出明确的决定（只有在所有参与者投赞成票的情况下才会提交）。协调者必须把这个决定写到磁盘上的事务日志中，如果它随后就崩溃，恢复后也能知道自己所做的决定。这被称为提交点（commit point）。
6. 一旦协调者的决定落盘，提交或放弃请求会发送给所有参与者。如果这个请求失败或超时，协调者必须永远保持重试，直到成功为止。没有回头路：如果已经做出决定，不管需要多少次重试它都必须被执行。如果参与者在此期间崩溃，事务将在其恢复后提交——由于参与者投了赞成，因此恢复后它不能拒绝提交。

### 协调者失效

### 三阶段提交

### 实践中的分布式任务

## XA事务

### 从协调者故障恢复

  一旦协调者出现故障，事务的事故只能通过运维人员手动调整。


## 公司